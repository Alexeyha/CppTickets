## 4. Функции
* ## Параметры
  * ### Синтаксис (пропущенное имя, значение по умолчанию в объявлении/определении)  
  У функции есть объявление и определение, хотя обычно они пишутся сразу вместе. У функции есть тип, название, в круглых скобках передаются параметры, в фигурных само тело функции.  
  ```C++
  void foo(int a, int b){}
  ```
  Можно в качестве параметра использовать агрумент без имени, указав только его тип. Это, например, используется, чтобы различять префиксный и постфиксный декриметны и инкременты. Обратиться к переданному таким образом аргументу внутри функции не получится. При этом распалагать их можно в перемешку с обычными аргументами, но до агрументов со значениями по умолчанию.  
  ```C++
  void foo1(int a, int, int b, int, int, int c = 100){} // OK
  void foo2(int a, int, int b, int, int, int c = 100, int){} // Compilation error
  void foo3(int a, int, int b, int, int, int c = 100, int = 1){} // OK
  ```
  Аргументы со значениями по умолчанию всегда идут после всех остальных. Можно передавать им новые значения при вызове функции. Задать значение по умолчанию можно как в объявлении, так и в определении функции, но только либо там, либо там.
  ```C++
  void foo1(int c = 100);
  void foo1(int c){
    std::cout << c; // Выводит 100
  }
  ```  
    
  * ### Передача параметров по: значению, `&`, `const&`. Что выбрать и почему.  
  Аргументы в функцию можно передавать по значению, по ссылке, по константной ссылке. Если передавать по значению, то в функцию копируется переданный аргумент. Если по ссылке, то берётся ссылка на переданный агрумент (то есть если теперь его поменять внутри функции, то он поменяется и в том месте, где была вызвана функция). Передача аргумента по константной ссылке не даёт нам изменять его внутри функции.  
  Передача по ссылке нужна, если мы хотим как-то модифицировать переданный аргумент в функцию.  
  Передача по константной ссылке нужна, если мы не хотим менять наш объект внутри функции. При этом, копировать его лишний раз слишком дорого (например копировать матрицу 1000 на 1000 элементов, по которой мы хотим лишь разок пробежаться, не редактируя её, тупо, потратим на это кучу лишнего времени), поэтому лучше передать его по ссылке и запретить редактирование.
  
  * ### Примеры: `push_back`, `Person(string first_name)`.  
  * ### Передача `{}` в параметры.  
  Компилятор умная штука. Можно передавать что-то в фигурных скобках, он по контексту догадается, чем это должно быть. Например тут он преобразует это в вектор интов.  
  ```C++
  void foo1(std::vector<int> arr){}
  int main() {
      foo1({1, 2, 3});
  }
  ```  
  * ### Неименованый параметр и `[[maybe_unused]]`  
  Неименованный параметр подробно описан выше. Вместо него можно использовать аргумент с каким-то фиктивным названием и пометить его `[[maybe_unused]]`  
  
* ## Возвращаемое значение
  * ### Возврат по значению, ссылке, константной ссылке.  
  При возврате по значению, возвращаемый объект будет копироваться в переменную, куда вы его запишите.  
  При возврате по ссылке, функция возвращается ссылку на объект. Поэтому стоит быть аккуратным. В следующем примере пытаемся вернуть ссылку на локальную переменную, которая уберётся со стека после окончания выполнения функции, поэтому получаем UB.  
  ```C++
  int& foo1(int a){
      int b = a + 1;
      return b; // UB
  }
  int main() {
      int c = foo1(4);
      std:: cout << c;
  }
  ```  
  Применять возращение значения по ссылке можно например, если нам в параметрах передали какой-то аргумент по ссылке. То есть после окончания функции, он не будет уничтожен, поэтому позвращать на него ссылку совершенно легально.  
  ```C++
  int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      int &b = foo1(c); // 6
      b++; // 7
      std::cout << c; // 7
  }
  ```
  Или например, можно возвращать ссылку на статический объект, объявленный внутри функции.
  ```C++
  int& foo1(){
      static int a = 100;
      a++;
      return a; // OK
  }
  int main() {
      int &c = foo1();
      std::cout << c << "\n"; // 101
      foo1();
      std::cout << c << "\n"; // 102
  }
  ```  
  Ну и можно возвращать константные ссылки. Всё работает интуитивно.  
  ```C++
  const int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      const int &b = foo1(c); // 6
      b++; // Compilation error
  }
  ```
  * ### Возврат `{}`.  
  Возвращение из функции `{}` возможно только если возвращать что-то по значению (ну очевидно, не понятно что бы означало вернуть ссылку на пустые скобки. Это просто не скомпилится). В этом случае, вызововется Default initialization у элемента возвращаемого типа. То есть если функция от инта, то вернётся 0.  
   ```C++
  int foo1(){
      return {};
  }
  int main() {
      std::cout << foo1(); // 0
  }
  ```
  * ### `[[nodiscard]]`, возможные стратегии применения: когда не имеет смысла игнорировать возвращаемое значение, когда игнорировать опасно  
  Например, опасно игнорировать возвращаемый объект какой-то структуры. Если мы использовали внутри функции Dynamic storage duration, и возвращаем какой-то объект, в предположении что его после нужно пудет удалить. Если же мы его никуда не сохраним, произойдёт утечка памяти. Имеет смысл запрещать игнорировать возвращаемое значение, например если мы переопределяем какой-то арифметический оператор, как `+` в `bigint`.  
* ## Перегрузка функций:
  * ### Что входит в сигнатуру, что не входит (например, значение по умолчанию).  
  Сигнатура функции - это описание её заголовка, в которое обычно входят:  
    1) имя функции 
    2) число и тип и порядок следоваения передаваемых в неё параметров (в т.ч. и то как именно они передаются, напр. по ссылке или по значению) 
    3) тип возвращаемого значения  
    Таким образом, сигнатура - это все что нужно знать (и не более того) о функции вызывающему её коду (т.е. для вызывающего кода важна только сигнатура, сама же реализация может быть черным ящиком).  
  * ### Синтаксис `= delete` с C++11.  
  Если мы хотим запретить, например копирующий конструктор, можем воспользоваться конструкцией = delete: чтобы пометить их как удаленные функции.  
  ```C++
  unique_ptr(const unique_ptr&) = delete;
  unique_ptr& operator=(const unique_ptr&) = delete;
  ```
  Отличие удаления этих функций от их объявления как private.Удаленные функции не могут использоваться никоим образом, так что даже код функциичлена или функций, объявленных как friend, не будет компилироваться, если попытается.  
  * ### Проблемы с разделением `nullptr`, `NULL`, `0`.  
  nullptr: это отдельный тип, а вот 0/NULL — это инты. Поэтому с перегрузками беда. Различие между NULL и 0 чаще всего практически никакого - (идеологически NULL показывает, что там пусто.  
  `#define NULL 0` //чаще все это именно так и есть  
  `nullptr` - значит что ни на что не указывает - необходимо использовать для указателей
  ```C++
  int *a=nullptr;
  *a; //UB!!!
  ```
  * ### Не было: `noexcept`.
  * ### Не было: правил выбора перегрузки точнее "выбирается перегрузка наиболее точная или ambiguous".
* ## Указатели на функции: синтаксис, использование.
  * ### Не было: конверсии между указателями, что происходит с перегрузками.

Тесно связано с: методы.
