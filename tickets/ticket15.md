### Жизнь объектов

## Семантика копирования

В C++ по умолчанию при присваивании объекта / 
передаче объекта в функцию или возврате из функции ожидается, что объект будет скопирован и 
изменения, произошедшие с копией не мутируют сам объект.

При этом существует способ создать ссылку на объект, то есть добавить новое имя для ровно того же объекта в памяти.
Для этого импользуется синтаксис `Type &refer = ....;`, функции также могут принимать аргументы по ссылке. 
При возвращении ссылки из функции нужно быть очень осторожным - локальные переменные умирают при завершении функции, 
возникает dangling reference - ссылка на умерший объект. Обращение по ней - UB. [stackowerflow](https://stackoverflow.com/questions/46011510/what-is-a-dangling-reference)


```c++
void foo(std::vector<int> a) {
    a.push_back(1);
    std::cout << a.size(); 
} 

void bar(std::vector<int>& a) {
    a.push_back(1);
    std::cout << a.size(); 
} 


int main() {
    std::vector<int> a{0};
    foo(a); // 2
    std::cout << a.size(); // 1 
    bar(a); // 2
    std::cout << a.size(); // 2  
    return 0;
}
```


**жирный текст** _курсив_ ~~ошибка~~ ==мнения?== `inline code block` [ссылка на фулл](https://www.markdownguide.org/cheat-sheet/)
```c++
int main() {
    return 0;
}
```

### Подзаголовок

LMAO
Not bottom text, lol
