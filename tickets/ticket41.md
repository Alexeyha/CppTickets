## Билет 41 (Базовое наследование)

### Совместимость по ссылкам и указателям

#### Устройство

В C++ совершенно бесплатно можно получить делать `basecast` (`upcast`): кастовать объект типа `Derived` (здесь и далее
считаем, что `Derived` наследуется от `Base`) к типу `Base&`, то есть получать ссылку на базу от Derived.

Причем делать это можно неявно, потому что мы считаем, что внутри памяти базовый класс лежит суперхорошо и приятно.

Заметим, что так делать можно и с указателями, все правила те же, преобразование такое неявное.

```c++
struct Base {
    int x = 10;
    void foo() const {
        std::cout << "x = " << x << std::endl;
    }
};

struct Derived : Base {
    int y = 20;
    void bar() const {
        std::cout << "x = " << x << " y = " << y << std::endl;
    }
};

int main() {
    Derived d;
    Base& b = d; // произошел basecast
    b.x++; // так можно
    b.y++; // так нельзя
    Derived* d_ptr = d;
    Base* b_ptr = d_ptr; 
    b_ptr->foo(); // OK
    b_ptr->bar(); // CE
```

#### Мотивация

Если у нас есть функция, которая должна работать на всех методах, отнаследованных от `Base`, то в целом upcast --
единственный способ сделать такое:

```c++
void foo(Base& b) {
    std:cout << "foo(" << b.x << ")" << std::endl;
}
```

Например, в STL такое используется при создании `operator>>` или `operator<<` для вывода. Подробнее: есть два как бы
базовых класса `istream` и `ostream`, от которых мы как раз делаем операторы, а потом `cin/cout` делают `upcast` к ним.

Второй пример уже от Егора. Пусть мы хотим реализовать двусвязный список с фиктивной вершиной (то есть с вершиной, в
которой не лежит никаких данных). Для этого можно реализовать базовый класс `node`, который будет содержать только
**указатели** на соседей и сделать от него наследника `node_with_data`, в которого дополнительно положить данные.

После этого добавление и удаление из списка ни коем образом не завязано на том какого типа у нас вершины. При этом, если
у нас фиктивная вершина только стартовая, то можно удобно итерироваться и получать данные при помощи derivedcast. Полный
код:

```c++
#include <iostream>

struct node {
    node *prev = nullptr;
    node *next = nullptr;
};

struct node_with_data : node {
    int data;

    node_with_data(int data_) : data(data_) {}
};

void link(node &x, node &y) {
    x.next = &y;
    y.prev = &x;
}

int main() {
    node l;
    node_with_data a(10), b(20), c(30);

    link(l, a);
    link(a, b);
    link(b, c);
    link(c, l);

    for (node *it = l.next; it != &l; it = it->next) {
        auto it_data = static_cast<node_with_data*>(it);
        std::cout << it_data->data << "\n";
    }
    std::cout << "=====\n";

    node_with_data d(40);
    link(a, d);
    link(d, b);

    for (node *it = l.next; it != &l; it = it->next) {
        auto it_data = static_cast<node_with_data*>(it);
        std::cout << it_data->data << "\n";
    }
}
```

#### Усиляем! (derived-cast)

Если в `foo` мы точно знаем, что переданная нам ссылка на `Base` пришла от `Derived`, то можно вернуться к `Derived`:

```c++
void foo(Base& b) {
    std:cout << "foo(" << b.x << ")" << std::endl;
    const Derived& d = static_cast<const Derived&>(b); // you need to use static_cast
}
```

Данный прием называется derivedcast или downcast. Прием очень опасный: его можно применять только в том случае, если мы
точно на 100% безошибочно знаем, что `b` -- на самом деле `Derived`. А иначе у нас будет UB, причем UB случится сразу в
момент каста, то есть даже если дальше мы не используем поля `Derived`.

Важный момент, что мы здесь используем `static_cast`. Вот, если хоть на секунду предположить, что мы его не используем,
то могут происходить различные страшные вещи. Например:

```c++
int main() {
    string s = "LOL!";
    int &x = (int&)(s); // UB
    cout << x << '\n'; // на моем компиляторе каждый запуск генерируется случайное число
}
```

Компилятор и слова не скажет о том, что вы не правы и так делать нельзя. А вот `static_cast` запретит вам компиляцию и
скажет, что вы не правы.

#### Усиляем x2 (slicing)

Пусть теперь у нас `foo` принимает не ссылку, а значение, то есть просто `Base`. После этого мы никогда не сможем делать
derivedcast, это всегда UB, UB ровно такое же, что и выше. Но! `foo` от `Derived` все еще можно вызвать. Это как раз и
называется `Slicing`, то есть "урезание".

Как это работает: когда мы делаем вызов `foo(d)`, то мы вызываем копирующий конструктор `Base(const Base &other)`, где
происходит basecast.

Методика избежания слайсинга похожа на знаменитый метод "Насильник, не насилуй". То есть, просто будьте аккуратнее,
следите за типами, передавайте по ссылке и не пишите плохой код.

### Расположение подобъектов в памяти и padding (пустое место для выравнивания).

Заметим, что если вывести `b_ptr` и `d_ptr`, то они неожиданным образом совпадут. Это ни разу не совпадение, стандарт
гарантирует, что базовый класс всегда лежит в начале производного класса.

Следующий момент: выравнивание размера. Каждый тип имеет свое выравнивание --- его адрес должен делиться на какое-то
хорошее число (например, адрес `int` должен делиться на 4, а адрес `char` на 1). Это пошло из некоторых особенностей архите

### Конструкторы и наследование: отличие от наследования обычных методов

Конструкторы не наследуется (специальные методы тоже, но они стараются сгенирироваться самостоятельно). Причем в
конструкторе `Derived` мы всегда обязаны сконструировать базовый класс, поэтому, если у `Base` нет конструктора по
умолчанию, то мы должны явно его вызвать. В отличие от других языков программирования, в C++ всего один способ вызвать
конструктор родительского класса: использовать member initialization list (когда задаем конструкторы через запятую после
двоеточия). Пример:

```c++
struct Base {
    int x;
    Base(int x_) : x(x_) {}
};

struct Derived : Base {
    int y = 20;

    Derived() : Base(10) {} // Здесь нельзя вызывать без Base(10)
//    Derived(int y_) : y(y_), Base(0) {}  // -Wreorder
//    Derived(int y_) : Base(y_), y(y_) {} // ok
    Derived(int y_) : Base(y_), y(y_) {}  // OK
};

struct SubDerived : Derived {
    SubDerived(int) {}  // : Derived() is implied. UB is apparent
};
```

Второй важный момент: родительские классы всегда инициализируются раньше, чем производные. Это очень важный принцип,
который используется дальше.